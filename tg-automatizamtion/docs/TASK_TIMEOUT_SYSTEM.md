# TASK TIMEOUT SYSTEM - Система защиты от зависаний

> Документ концепции реализации системы аварийного сброса при зависании обработки чатов.

---

## Суть проблемы

При обработке Telegram чатов worker-процесс может "зависнуть" на одном чате бесконечно долго. Причины разные: попап перехватывает клики, медленный интернет, изменения в UI Telegram, зависание Playwright на операциях без явного таймаута.

Текущая архитектура не имеет общего таймаута на обработку одного чата. Функция `_process_task()` в worker.py выполняет последовательность операций (поиск, открытие, проверка ограничений, отправка), каждая из которых может зависнуть. Конструкция try/except ловит только исключения, но не зависания.

Если какой-либо await никогда не завершится - worker заморожен навсегда, другие чаты не обрабатываются.

---

## Концепция решения

Вместо попыток угадать все возможные причины зависания - устанавливаем общий таймаут на всю обработку чата. При срабатывании таймаута выполняем аварийный сброс состояния браузера и переходим к следующему чату.

### Ключевые принципы

1. **Общий таймаут** - один таймаут на всю обработку чата (поиск + открытие + отправка)
2. **Конфигурируемость** - значение таймаута задаётся в config.yaml (по умолчанию 120 секунд)
3. **Отдельный статус** - новый статус `timeout` в таблице tasks для отслеживания
4. **Глобальный счётчик** - поле timeout_count считается по всем профилям, а не по одному
5. **Автоматическая блокировка** - после 3 таймаутов (настраивается) задача блокируется

---

## Механизм аварийного сброса

При срабатывании таймаута выполняется трёхуровневый сброс состояния браузера.

### Уровень 1: Мягкий сброс (Escape)

Нажатие клавиши Escape дважды с паузой 300 мс между нажатиями.

Что закрывает:
- Любые попапы (например "Never miss a message", Stars)
- Модальные окна
- Выпадающие меню
- Режим редактирования

Почему дважды: первый Escape может закрыть попап, второй - выйти из режима поиска.

### Уровень 2: Очистка поиска

Поиск кнопки очистки поиска (селектор `button.input-search-clear`). Если кнопка видима - клик на неё с ожиданием 500 мс.

Что делает:
- Очищает поле поиска
- Убирает результаты поиска
- Возвращает на обычный список чатов

### Уровень 3: Жёсткий сброс (reload)

Если уровни 1-2 не помогли - полная перезагрузка страницы через переход на URL Telegram заново.

Что делает:
- Полностью сбрасывает состояние браузера
- Закрывает все открытые чаты
- Очищает поиск
- Возвращает на главную

Этот уровень обёрнут в отдельный таймаут 15 секунд. Если и reload завис - идём дальше без повторной попытки.

---

## Глобальность счётчика таймаутов

Счётчик `timeout_count` хранится в таблице tasks (а не в связке task+profile). Это означает что таймауты от разных профилей суммируются.

Пример сценария:
- Профиль A пробует чат @example - таймаут - timeout_count = 1
- Профиль B пробует чат @example - таймаут - timeout_count = 2
- Профиль C пробует чат @example - таймаут - timeout_count = 3 - БЛОКИРОВКА

Логика: если чат зависает у разных профилей - проблема в самом чате, а не в профиле. Значит нужно блокировать чат.

---

## Конфигурация

### Новые параметры в config.yaml

В секции timeouts добавляется параметр `task_timeout` - общий таймаут на обработку одного чата в секундах. По умолчанию 120 секунд.

В секции retry добавляется параметр `max_timeouts_before_block` - максимальное количество таймаутов до блокировки задачи. По умолчанию 3.

### Логика значений

Нормальная обработка чата занимает 15-30 секунд. Если за 2 минуты не справились - явно что-то не так.

Даём 3 шанса на таймаут. Если чат 3 раза зависает (с любыми профилями) - блокируем как проблемный.

---

## Изменения в базе данных

### Новое поле timeout_count

В таблицу tasks добавляется поле `timeout_count` типа INTEGER со значением по умолчанию 0. Это глобальный счётчик таймаутов для каждого чата.

### Новый статус timeout

К существующим статусам задач (pending, in_progress, completed, blocked) добавляется новый статус `timeout`. Задачи с этим статусом обрабатываются наравне с pending - они возвращаются в очередь после установленной паузы.

### View timeout_stats

Создаётся SQL view для быстрого просмотра статистики по таймаутам. View показывает: идентификатор задачи, группу, username чата, количество таймаутов, статус, флаг блокировки, общее количество попыток с таймаутом, время последнего таймаута.

---

## Файлы, затрагиваемые изменениями

### config.yaml
Добавление параметров task_timeout и max_timeouts_before_block.

### src/config.py
Добавление полей в dataclass TimeoutsConfig (task_timeout) и RetryConfig (max_timeouts_before_block).

### db/migrate_timeout_system.sql
SQL миграция: добавление поля timeout_count в таблицу tasks, создание view timeout_stats.

### src/database.py
Добавление методов для работы с таймаутами:
- increment_task_timeout_count - увеличить счётчик на 1
- get_task_timeout_count - получить текущее значение счётчика
- set_task_status_timeout - установить статус timeout

Обновление метода get_next_incomplete_task - включить статус timeout в выборку задач.

### src/telegram_sender.py
Добавление метода go_to_main() для аварийного сброса состояния браузера. Метод реализует трёхуровневый сброс: Escape, очистка поиска, reload.

### src/error_handler.py
Добавление метода handle_task_timeout() для обработки события таймаута. Метод логирует событие, увеличивает счётчик, проверяет лимит и либо блокирует задачу, либо устанавливает статус timeout с паузой перед следующей попыткой.

### src/worker.py
Главное изменение: оборачивание вызова _process_task() в asyncio.wait_for() с таймаутом из конфига. При срабатывании asyncio.TimeoutError выполняется вызов telegram.go_to_main() и error_handler.handle_task_timeout().

### src/task_queue.py
Обновление метода get_next_incomplete_task - добавить статус timeout в условие выборки задач. Задачи со статусом timeout должны обрабатываться наравне с pending.

---

## Поток обработки

### Нормальная обработка (без таймаута)

1. Получение задачи из очереди (статус pending)
2. Запуск обработки с таймером
3. Поиск чата - успех
4. Открытие чата - успех
5. Отправка сообщения - успех
6. Пометка задачи как success
7. Переход к следующей задаче

### Обработка с таймаутом

1. Получение задачи из очереди
2. Запуск обработки с таймером (120 секунд)
3. Поиск чата - зависает...
4. Проходит 120 секунд
5. Срабатывает asyncio.TimeoutError
6. Вызов go_to_main() - аварийный сброс браузера
7. Вызов handle_task_timeout():
   - Увеличение timeout_count на 1
   - Проверка: timeout_count >= 3?
   - Если да - блокировка задачи, статус blocked
   - Если нет - статус timeout, next_available_at через 5 минут
8. Переход к следующей задаче

### Повторная обработка после таймаута

1. Получение задачи из очереди (статус timeout, next_available_at прошло)
2. Обычная обработка...
3. Если успех - счётчик timeout_count НЕ сбрасывается
4. Если снова таймаут - timeout_count увеличивается

---

## Логирование

При таймауте в main.log записывается сообщение об ошибке с указанием чата и времени таймаута. Далее записывается информация о выполнении аварийного сброса. Затем записывается текущее значение счётчика таймаутов и максимум.

В таблицу task_attempts добавляется запись со статусом failed и типом ошибки task_timeout.

В таблицу send_log добавляется запись с типом ошибки task_timeout и деталями.

---

## Тестирование

### Проверка срабатывания таймаута
Установить task_timeout в 5 секунд в конфиге. Запустить автоматизацию. Любой чат должен завершиться по таймауту.

### Проверка аварийного сброса
Убедиться что после таймаута браузер вернулся на главную страницу. Убедиться что следующий чат обрабатывается корректно.

### Проверка блокировки
Установить max_timeouts_before_block в 1. После первого таймаута чат должен заблокироваться.

### Проверка глобальности счётчика
Запустить 2 профиля на одном проблемном чате. Счётчик должен накапливать таймауты от обоих профилей.

---

## Порядок реализации

1. Обновить config.yaml и src/config.py - добавить новые параметры
2. Создать миграцию БД - поле timeout_count и view
3. Выполнить миграцию на сервере PostgreSQL
4. Добавить методы в database.py
5. Добавить метод go_to_main() в telegram_sender.py
6. Добавить метод handle_task_timeout() в error_handler.py
7. Обновить worker.py - обернуть в asyncio.wait_for
8. Обновить task_queue.py - добавить статус timeout в выборку
9. Тестирование
10. Деплой

---

**Дата создания:** 2024-12-25
**Статус:** Концепция утверждена, готово к реализации
