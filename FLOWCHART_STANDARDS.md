# Правила создания Flowchart-диаграмм

## Назначение

Flowchart-диаграммы используются для фиксации **логики работы** на уровне Low-level перед началом реализации. Диаграммы создаются в Excalidraw для интерактивного редактирования.

**Важно:** Все фазы и этапы системы создаются в **едином Excalidraw файле** с вертикальной структурой.

---

## 1. Обязательные технические требования

### 1.1. Связывание элементов (Excalidraw)

**Стрелки:**
- ВСЕГДА должны иметь `startBinding` и `endBinding`
- Обе стороны стрелки привязаны к блокам

**Текст:**
- ВСЕГДА находится внутри блока через `containerId`
- Свободный текст запрещён

### 1.2. Уровень детализации

**Low-level:** детальное пошаговое описание логики.

---

## 2. Элементы блок-схем

### 2.1. Фигуры

| Фигура | Назначение |
|--------|------------|
| **Прямоугольник** | Действие или процесс |
| **Ромб** | Условие (вопрос с ответом да/нет) |
| **Овал** | Начало или конец |

### 2.2. Стрелки

- Показывают **направление** выполнения
- **Без подписей**
- Основное направление: **вертикально** (сверху вниз)

---

## 3. Стандарты оформления

- **Размер блока:** 200x80 пикселей (увеличивать при необходимости для детального содержимого)
- **Grid:** 20 пикселей
- **Шрифт:** читаемый размер (минимум 14-16px), четкий и разборчивый
- **Текст в блоках:** достаточно крупный для чтения без увеличения

---

## 4. Базовые паттерны

### 4.1. Последовательность

Линейное выполнение:

```
[Действие 1]
     ↓
[Действие 2]
     ↓
[Действие 3]
```

### 4.2. Условие

Ветвление:

```
   [Условие?] ◇
      ↓   ↓
     да   нет
     ↓    ↓
   [A]   [B]
```

### 4.3. Цикл

Повторение:

```
[Инициализация]
      ↓
   [Продолжить?] ◇
      ↓    ↓
     да   нет → [Выход]
      ↓
  [Действие]
      ↓
      ← (назад к условию)
```

---

## 5. Когда создавать

- **Перед реализацией** для планирования алгоритма
- Для логики с условиями, циклами, ветвлениями
- Когда нужна визуализация последовательности действий

---

## 6. Как описывать блоки

### 6.1. Действия

Используйте **глаголы** для описания операций:

✅ **Правильно:**
- "Получить задачу"
- "Проверить доступность"
- "Отправить сообщение"
- "Записать результат"

❌ **Неправильно:**
- "task = get_task()"
- "db.query()"
- "send_message(chat, text)"

### 6.2. Условия

Формулируйте как **вопросы**:

✅ **Правильно:**
- "Задача найдена?"
- "Чат доступен?"
- "Ошибка возникла?"

❌ **Неправильно:**
- "task is not None"
- "if available"
- "status == 200"

### 6.3. Начало/конец

Краткое **описание процесса**:

✅ **Правильно:**
- "Начало: Обработка задачи"
- "Конец"

---

## 7. Пример: Обработка задачи (детальный)

**Пример показывает блоки с достаточной детализацией для спецификации:**

```
[Начало: Обработка задачи воркером]
         ↓
[Получить следующую задачу
• Проверить лимиты профиля (макс/час)
• Атомарная операция UPDATE+RETURNING
• Приоритет: меньше completed_cycles
• Фильтр: status=pending, is_blocked=0]
         ↓
   [Задача найдена?] ◇
      ↓          ↓
     да         нет → [Ожидать или завершить
                      • Если достигнут лимит: выход
                      • Иначе: задержка 30 сек]
      ↓                  ↓
[Запустить браузер     [Конец]
• Загрузить профиль Donut Browser
• Применить fingerprint (env vars)
• Настроить прокси
• Открыть web.telegram.org/k
• Ждать загрузки (поле поиска)]
      ↓
[Найти чат
• Очистить поле поиска
• Ввести chat_username
• Ждать появления результатов
• Таймаут: search_timeout (10 сек)
• До 3 попыток с паузами]
      ↓
   [Чат найден?] ◇
      ↓         ↓
     да        нет → [Обработать ошибку
      ↓              • Скриншот → warnings/
[Открыть чат         • Лог → failed_chats.log
• Клик по элементу   • Блокировать задачу (is_blocked=1)
• Ждать topbar       • block_reason="chat_not_found"]
• Проверить загрузку]                ↓
      ↓                           [Конец]
[Проверить ограничения
• JOIN кнопка? → автокликнуть
• Premium required? → ошибка
• User blocked? → ошибка
• Нет поля ввода? → ошибка]
      ↓
 [Можно отправить?] ◇
      ↓         ↓
     да        нет → [Записать причину ограничения
      ↓              • Лог → failed_send.log
[Отправить сообщение • Скриншот → warnings/
• Выбрать случайное  • task_attempt (status=failed)
  из БД              • НЕ блокировать задачу]
• Вставить в поле              ↓
• Триггер 'input'           [Конец]
• Клик по кнопке
• Таймаут: 5 сек]
      ↓
   [Успешно?] ◇
      ↓      ↓
    да      нет → [Записать ошибку
     ↓              • Скриншот → errors/
[Записать успех       • task_attempt (status=failed)
• task_attempt        • Увеличить failed_count
  (status=success)    • Лог с деталями]
• Увеличить                ↓
  success_count          [Конец]
• completed_cycles++
• messages_sent_current_hour++
• Лог → success.log]
     ↓
[Проверить завершение
• Если completed_cycles = total_cycles
  → status='completed'
• Иначе → установить задержку
  next_available_at = now + cycle_delay]
     ↓
[Применить задержку между сообщениями
• Базовая: 3600 / max_messages_per_hour
• Рандомизация: ±20%
• Пример: 120 сек → 96-144 сек]
     ↓
[Конец]
```

---

## 8. Структурирование больших диаграмм

При создании диаграмм с большим количеством блоков важно правильно организовать пространство.

### 8.1. Визуальная группировка

- Связанные блоки группировать визуально (отступами, расположением)
- Каждый логический этап размещать в отдельной вертикальной зоне
- Использовать горизонтальное пространство для параллельных путей
- Обработка ошибок и альтернативные пути - справа или слева от основного потока

### 8.2. Организация пространства

- **Основной поток:** по центру вертикально (сверху вниз)
- **Ветвления:** расходятся горизонтально, затем возвращаются к центральному потоку
- **Циклы:** визуально выделять отступом или отдельной зоной
- **Ошибки:** отдельная вертикальная зона справа или слева

**Пример организации:**

```
        [Инициализация]
              ↓
    ┌─────────────────┐
    │ ОСНОВНОЙ ПОТОК  │
    │  [Действие 1]   │
    │       ↓         │
    │  [Действие 2]   │
    └─────────────────┘
              ↓
    ┌─────────────────┐          ┌──────────────┐
    │  [Проверить]◇───┼──────────→ [Обработать  │
    │       ↓         │          │   ошибку]    │
    │  [Продолжить]   │          │      ↓       │
    └─────────────────┘          │  [Завершить] │
              ↓                  └──────────────┘
          [Конец]
```

---

## 9. Связывание блоков

### 9.1. Избегать пересечений

- Планировать расположение блоков так, чтобы стрелки не пересекались
- Если пересечение неизбежно - использовать разные горизонтальные уровни

### 9.2. Ясность связей

- От условия (ромба) сначала идут обе ветки, потом сходятся обратно
- Возвраты в цикл - четко показывать стрелкой назад к началу цикла
- Множественные выходы из процесса - каждый ведет к своему "Конец"

---

## 10. Иерархия информации

### 10.1. Выделение главного

- **Основной "счастливый путь"** - по центру, более крупные блоки
- **Альтернативные пути** - по бокам, стандартный размер
- **Обработка исключений** - отдельно справа или слева

### 10.2. Визуальное внимание

- Важные решения - размещать в центре внимания
- Второстепенные проверки - можно группировать или выносить в сторону

---

## 11. Последовательность фаз

Когда описание содержит несколько этапов (например: Инициализация → Запуск → Обработка → Завершение):

### 11.1. Разделение на секции

- Каждый крупный этап - отдельная вертикальная секция диаграммы
- Между секциями - визуальный отступ (пустое пространство)
- Секции идут сверху вниз в порядке выполнения

### 11.2. Структура многофазной диаграммы

**Важно:** Все фазы размещаются вертикально в **едином Excalidraw файле**. Не создавать отдельные файлы для разных фаз.

**Пример для системы из нескольких фаз (в одном файле):**

```
[ФАЗА 1: ИНИЦИАЛИЗАЦИЯ]
[Создать конфигурацию
• Загрузить config.yaml
• Валидировать параметры]
         ↓
[Инициализировать БД
• Создать таблицы если нет
• Включить WAL режим]
         ↓

     (отступ между фазами)

[ФАЗА 2: ЗАПУСК]
[Загрузить профили
• Сканировать папку profiles/
• Читать metadata.json
• Фильтр: is_active = true]
         ↓
[Запустить воркеры
• Создать процесс для каждого
• Передать profile_id]
         ↓

     (отступ между фазами)

[ФАЗА 3: ОСНОВНОЙ ЦИКЛ]
[Получить задачу
• Проверить лимиты
• Атомарная операция]
         ↓
     ... и так далее
```

---

## 12. Детализация блоков

### 12.1. Разбиение сложных действий

- Если действие состоит из нескольких шагов - разбить на несколько блоков последовательно
- Если проверка имеет несколько условий - показать каждое условие отдельным ромбом
- Не пытаться уместить множество действий в один блок

**Пример:**

❌ **Неправильно:**
```
[Запустить браузер, открыть Telegram, войти в аккаунт, найти чат]
```

✅ **Правильно:**
```
[Запустить браузер]
         ↓
[Открыть Telegram]
         ↓
[Войти в аккаунт]
         ↓
[Найти чат]
```

### 12.2. Фиксация всех деталей

- Включать ВСЕ важные шаги из описания логики
- Показывать все значимые условия и проверки
- Отражать все пути выполнения (успех, ошибки, альтернативы)
- Не упрощать логику - цель зафиксировать полную картину

### 12.3. Детализация содержимого блоков

Каждый блок должен содержать достаточно информации для использования как **спецификация**.

❌ **Недостаточно детально:**
```
[Получить задачу]
```

✅ **Правильно (полноценная спецификация):**
```
[Получить задачу из очереди
• Проверить лимиты профиля (макс/час)
• Атомарная операция UPDATE+RETURNING
• Приоритет: меньше циклов
• Исключить: заблокированные, в задержке
• Назначить assigned_profile_id
• Вернуть: task_id, chat_username]
```

❌ **Недостаточно:**
```
[Обработать ошибку]
```

✅ **Правильно:**
```
[Обработать ошибку: чат не найден
• Сделать скриншот → warnings/
• Записать в failed_chats.log
• Создать task_attempt (status=failed)
• Заблокировать задачу навсегда (is_blocked=1)
• Установить block_reason = "chat_not_found"
• Увеличить failed_count]
```

❌ **Недостаточно:**
```
[Отправить сообщение]
```

✅ **Правильно:**
```
[Отправить сообщение в чат
• Выбрать случайное сообщение из БД
• Вставить в поле ввода (contenteditable)
• Триггер события 'input'
• Ждать появления кнопки отправки
• Клик по кнопке
• Таймаут: send_timeout (5 сек)
• Записать usage_count++]
```

### 12.4. Блоки как спецификация

Каждый блок должен отвечать на вопросы:

- **Что делается?** (главное действие - в заголовке блока)
- **Как делается?** (ключевые шаги - списком)
- **Что проверяется?** (условия, фильтры)
- **Что записывается?** (логи, БД)
- **Важные параметры** (таймауты, лимиты, настройки)

**Принцип:** Разработчик должен понять **ЧТО реализовать**, читая только содержимое блока, без обращения к другим документам.

---

## Правила составления

- ✅ Каждое правило **один раз**
- ✅ Без **противоречий**
- ✅ Без **дублирования**
- ✅ Описание **словами**, не кодом
- ✅ Фиксировать **всю логику** подробно и структурированно
- ✅ Все фазы в **едином Excalidraw файле**
- ✅ Каждый блок содержит **достаточно деталей** для использования как спецификация
- ✅ **Читаемый шрифт** (минимум 14-16px)
